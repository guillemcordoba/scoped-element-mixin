{"version":3,"file":"ScopedElementMixin.js","sourceRoot":"","sources":["../src/ScopedElementMixin.ts"],"names":[],"mappings":"AAAA,OAAO,mBAAmB,CAAC;AAc3B,MAAM,CAAC,MAAM,MAAM,GAAG,CAAC,SAA6B,EAAE,EAAE,CACtD,KAAM,SAAQ,SAAS;IAGrB,MAAM,KAAK,cAAc;QACvB,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,gBAAgB;QACd,OAAO,IAAI,CAAC,YAAY,CAAC;YACvB,IAAI,EAAE,MAAM;YACZ,cAAc,EAAE,IAAI,qBAAqB,EAAE;SACrC,CAAC,CAAC;IACZ,CAAC;IAED,iBAAiB;QACf,IAAI,KAAK,CAAC,iBAAiB,EAAE;YAC3B,KAAK,CAAC,iBAAiB,EAAE,CAAC;SAC3B;QAED,MAAM,QAAQ,GAAI,IAAI,CAAC,WAAiC,CAAC,cAAc,CAAC;QAExE,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YACvC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,MAAM,CAAC,GAAG,EAAE,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;SAC3D;IACH,CAAC;CACF,CAAC","sourcesContent":["import \"scoped-registries\";\n\nexport type Dictionary<T> = { [key: string]: T };\n\ndeclare global {\n  interface HTMLElement {\n    connectedCallback?(): void;\n  }\n}\n\nexport type ScopedElementType = typeof HTMLElement & {\n  scopedElements: Dictionary<typeof HTMLElement>;\n};\n\nexport const Scoped = (baseClass: typeof HTMLElement) =>\n  class extends baseClass {\n    shadowRoot!: ShadowRoot & { customElements: CustomElementRegistry };\n\n    static get scopedElements(): Dictionary<typeof HTMLElement> {\n      return {};\n    }\n\n    createRenderRoot() {\n      return this.attachShadow({\n        mode: \"open\",\n        customElements: new CustomElementRegistry(),\n      } as any);\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) {\n        super.connectedCallback();\n      }\n\n      const elements = (this.constructor as ScopedElementType).scopedElements;\n\n      for (const tag of Object.keys(elements)) {\n        this.shadowRoot.customElements.define(tag, elements[tag]);\n      }\n    }\n  };\n"]}