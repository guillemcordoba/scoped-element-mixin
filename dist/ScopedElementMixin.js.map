{"version":3,"file":"ScopedElementMixin.js","sourceRoot":"","sources":["../src/ScopedElementMixin.ts"],"names":[],"mappings":"AACA,OAAO,mBAAmB,CAAC;AAe3B,MAAM,CAAC,MAAM,MAAM,GAAG,CACpB,SAAY,EACoB,EAAE,CAClC,KAAM,SAAQ,SAAS;IAGrB,IAAI,cAAc;QAChB,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,gBAAgB;QACd,OAAO,IAAI,CAAC,YAAY,CAAC;YACvB,IAAI,EAAE,MAAM;YACZ,cAAc,EAAE,IAAI,qBAAqB,EAAE;SACrC,CAAC,CAAC;IACZ,CAAC;IAED,iBAAiB;QACf,IAAI,KAAK,CAAC,iBAAiB,EAAE;YAC3B,KAAK,CAAC,iBAAiB,EAAE,CAAC;SAC3B;QAED,MAAM,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC;QAErC,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YACvC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,MAAM,CAAC,GAAG,EAAE,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;SAC3D;IACH,CAAC;CACF,CAAC","sourcesContent":["import { Constructor } from \"lit-element\";\nimport \"scoped-registries\";\n\nexport type Dictionary<T> = { [key: string]: T };\n\ndeclare global {\n  interface HTMLElement {\n    connectedCallback?(): void;\n  }\n}\n\nexport interface ScopedElement extends HTMLElement {\n  readonly scopedElements: Dictionary<typeof HTMLElement>;\n  shadowRoot: ShadowRoot & { customElements: CustomElementRegistry };\n}\n\nexport const Scoped = <T extends Constructor<HTMLElement>>(\n  baseClass: T\n): T & Constructor<ScopedElement> =>\n  class extends baseClass {\n    shadowRoot!: ShadowRoot & { customElements: CustomElementRegistry };\n\n    get scopedElements(): Dictionary<typeof HTMLElement> {\n      return {};\n    }\n\n    createRenderRoot() {\n      return this.attachShadow({\n        mode: \"open\",\n        customElements: new CustomElementRegistry(),\n      } as any);\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) {\n        super.connectedCallback();\n      }\n\n      const elements = this.scopedElements;\n\n      for (const tag of Object.keys(elements)) {\n        this.shadowRoot.customElements.define(tag, elements[tag]);\n      }\n    }\n  };\n"]}