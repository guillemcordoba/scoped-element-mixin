{"version":3,"file":"scoped.js","sourceRoot":"","sources":["../src/scoped.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,mBAAmB,EAAE,MAAM,0BAA0B,CAAC;AAE/D,MAAM,CAAC,MAAM,YAAY,GAAG,CAC1B,IAAO,EACJ,EAAE;IACL,IAAM,IAAwB,CAAC,SAAS;QACtC,OAAQ,eAAe,CACpB,IAAuC,CAC5B,CAAC;;QACZ,OAAO,gBAAgB,CAAC,IAAI,CAAC,CAAC;AACrC,CAAC,CAAC;AAEF,MAAM,gBAAgB,GAAG,CAAqC,IAAO,EAAE,EAAE,CACvE,KAAM,SAAQ,IAAI;IAChB,YAAY,GAAG,IAAW;QACxB,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;QAEf,MAAM,QAAQ,GAAI,IAAI,CAAC,WAAwC;aAC5D,cAAc,CAAC;QAClB,IAAI,QAAQ,EAAE;YACZ,IAAI,CAAC,YAAY,CAAC;gBAChB,IAAI,EAAE,MAAM;gBACZ,cAAc,EAAE,IAAI,qBAAqB,EAAE;aACrC,CAAC,CAAC;SACX;IACH,CAAC;IAED,iBAAiB;QACf,IAAI,KAAK,CAAC,iBAAiB,EAAE;YAC3B,KAAK,CAAC,iBAAiB,EAAE,CAAC;SAC3B;QAED,MAAM,QAAQ,GAAI,IAAI,CAAC,WAAwC;aAC5D,cAAc,CAAC;QAClB,IAAI,QAAQ,EAAE;YACZ,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;gBACpC,IAAI,CAAC,UAEN,CAAC,cAAwC,CAAC,MAAM,CAChD,GAAG,EACH,YAAY,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAC5B,CAAC;aACH;SACF;IACH,CAAC;CACF,CAAC;AAEJ,MAAM,eAAe,GAAG,CAAoC,IAAO,EAAK,EAAE,CACxE,KAAM,SAAQ,mBAAmB,CAAC,IAAI,CAAC;IACrC,MAAM,KAAK,cAAc;QACvB,IAAM,IAA6C,CAAC,cAAc,EAAE;YAClE,MAAM,QAAQ,GAAK,IAA6C;iBAC7D,cAAc,CAAC;YAElB,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;gBACvC,QAAQ,CAAC,GAAG,CAAC,GAAG,YAAY,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;aAC7C;YACD,OAAO,QAAQ,CAAC;SACjB;;YAAM,OAAO,EAAE,CAAC;IACnB,CAAC;CACF,CAAC","sourcesContent":["import { ScopedElementConstructor } from \"./types\";\nimport { Constructor, LitElement } from \"lit-element\";\nimport { ScopedElementsMixin } from \"@open-wc/scoped-elements\";\n\nexport const scopeElement = <T extends Constructor<HTMLElement>>(\n  base: T\n): T => {\n  if (((base as unknown) as any).getStyles)\n    return (scopeLitElement(\n      (base as any) as Constructor<LitElement>\n    ) as any) as T;\n  else return scopeHTMLElement(base);\n};\n\nconst scopeHTMLElement = <T extends Constructor<HTMLElement>>(base: T) =>\n  class extends base {\n    constructor(...args: any[]) {\n      super(...args);\n\n      const elements = (this.constructor as ScopedElementConstructor)\n        .scopedElements;\n      if (elements) {\n        this.attachShadow({\n          mode: \"open\",\n          customElements: new CustomElementRegistry(),\n        } as any);\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) {\n        super.connectedCallback();\n      }\n\n      const elements = (this.constructor as ScopedElementConstructor)\n        .scopedElements;\n      if (elements) {\n        for (const tag of Object.keys(elements)) {\n          (((this.shadowRoot as any) as {\n            customElements: CustomElementRegistry;\n          }).customElements as CustomElementRegistry).define(\n            tag,\n            scopeElement(elements[tag])\n          );\n        }\n      }\n    }\n  };\n\nconst scopeLitElement = <T extends Constructor<LitElement>>(base: T): T =>\n  class extends ScopedElementsMixin(base) {\n    static get scopedElements() {\n      if (((base as unknown) as ScopedElementConstructor).scopedElements) {\n        const elements = ((base as unknown) as ScopedElementConstructor)\n          .scopedElements;\n\n        for (const key of Object.keys(elements)) {\n          elements[key] = scopeElement(elements[key]);\n        }\n        return elements;\n      } else return {};\n    }\n  };\n"]}